#! /usr/bin/env perl6

use v6.c;

use File::Temp;
use Perl6::Utils;
use Perl6::Documentable::Registry;
use Perl6::Documentable::To::HTML;
use Pod::Load;
use Pod::Utilities::Build;
use Perl6::TypeGraph::Viz;
use JSON::Fast;

my %*POD2HTML-CALLBACKS;

sub MAIN (
    Str  :$topdir              = "doc",
    Bool :v(:verbose($v))      = False,
    Bool :c(:$cache)           = True ,
    Bool :p(:pods($p))         = False,
    Bool :s(:search-index($s)) = False,
    Bool :i(:indexes($i))      = False,
    Bool :t(:type-images($t))  = False,
    Bool :f(:force($f))        = False,
    Bool :$highlight           = False,
    Bool :a(:$all)             = False
) {
    # to track the time
    my $now;

    # debug function
    sub DEBUG($msg) {
        say $msg if $v;
    }

    # highlights workaround
    DEBUG("Starting highlight process...");
    highlight-code-blocks if $highlight;

    #===================================================================

    DEBUG("Creating subdirectories...");
    for <programs type language routine images syntax> {
        mkdir "html/$_" unless "html/$_".IO ~~ :e;
    }

    #===================================================================
    
    $now = now;
    DEBUG("Setting Perl6::Documentable::Registry...");
    my $registry = Perl6::Documentable::Registry.new(use-cache => $cache,
                                                    verbose   => $v
                                                );
    print-time("Setting up the registry", $now);    
    
    #===================================================================
    
    $now = now;
    if ($t || $all) {
        DEBUG("Writing type-graph representations...");
        my $viz = Perl6::TypeGraph::Viz.new;
        $viz.write-type-graph-images(path       => "html/images", 
                                    force      => $f,
                                    type-graph => $registry.tg)
    }
    print-time("Typegraph representations", $now);
    
    #===================================================================
    
    $now = now;
    DEBUG("Processing phase...");
    for <Language Programs Type Native> {
        $registry.process-pod-dir(:topdir($topdir), :dir($_));
    }
    $registry.compose;
    print-time("Processing pods", $now);
    
    #===================================================================
    
    DEBUG("Writing html/index.html and html/404.html...");
    spurt 'html/index.html', p2h(load('doc/HomePage.pod6')[0], :pod-path('HomePage.pod6'));
    spurt 'html/404.html', p2h(load('doc/404.pod6')[0], :pod-path('404.pod6'));

    #===================================================================
    
    $now = now;
    if ($p || $all ) {
        DEBUG("HTML generation phase...");
        for <programs language type> -> $kind {
            for $registry.lookup($kind, :by<kind>).list -> $doc {
                DEBUG("Writing $kind document for {$doc.name} ...");
                spurt "html{$doc.url}.html", source-html($kind, $doc);
            }
        }
    }
    print-time("Writing source files", $now);

    #===================================================================

    $now = now;
    if ($i || $all) {
        DEBUG("Index generation phase...");

        DEBUG("Writing html/programs.html ...");
        spurt 'html/programs.html', programs-index-html($registry.programs-index);

        DEBUG("Writing html/language.html ...");
        spurt 'html/language.html', language-index-html($registry.language-index, True);

        DEBUG("Writing html/type.html ...");
        spurt 'html/type.html', type-index-html($registry.type-index);

        DEBUG("Writing html/routine.html ...");
        spurt 'html/routine.html', routine-index-html($registry.routine-index);

        DEBUG("Subindex generation phase...");

        for <basic composite domain-specific exceptions> -> $category {
            DEBUG("Writing html/type-$category.html ...");
            spurt "html/type-$category.html", 
            type-subindex-html($registry.type-subindex(:$category), $category);        
        }

        for <sub method term operator trait submethod> -> $category {
            DEBUG("Writing html/routine-$category.html ...");
            spurt "html/routine-$category.html", 
            routine-subindex-html($registry.routine-subindex(:$category), $category);        
        }
    }
    print-time("Writing index files", $now);    

    #===================================================================

    if ($s || $all ) {
        DEBUG("Writing search file...");
        mkdir 'html/js';
        spurt "html/js/search.js", search-file($registry.generate-search-index);
    }

}

sub highlight-code-blocks {
    my $proc;
    my $proc-supply;
    my $coffee-exe = './highlights/node_modules/coffee-script/bin/coffee'.IO.e??'./highlights/node_modules/coffee-script/bin/coffee'!!'./highlights/node_modules/coffeescript/bin/coffee';

    if ! $coffee-exe.IO.f {
        say "Could not find $coffee-exe, did you run `make init-highlights`?";
        exit 1;
    }
    $proc = Proc::Async.new($coffee-exe, './highlights/highlight-filename-from-stdin.coffee', :r, :w);
    $proc-supply = $proc.stdout.lines;

    $proc.start andthen say "Starting highlights worker thread" unless $proc.started;
    %*POD2HTML-CALLBACKS = code => sub (:$node, :&default) {
        for @($node.contents) -> $c {
            if $c !~~ Str {
                # some nested formatting code => we can't highlight this
                return default($node);
            }
        }
        my ($tmp_fname, $tmp_io) = tempfile;
        $tmp_io.spurt: $node.contents.join, :close;
        my $html;
        my $promise = Promise.new;
        my $tap = $proc-supply.tap( -> $json {
            my $parsed-json = from-json($json);
            if $parsed-json<file> eq $tmp_fname {
                $promise.keep($parsed-json<html>);
                $tap.close();
            }
        } );
        $proc.say($tmp_fname);
        await $promise;
        $promise.result;
    }
}  

sub print-time($phase, $start) {
    my $now = now;
    say "\e[1;36m$phase has taken {$now-$start} seconds \e[0m";
}